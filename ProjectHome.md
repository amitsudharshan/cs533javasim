**J-Core**  is a component based strongly timed simulation platform written in JAVA. The framework allows components to register and interact with each other based on simple contracts, and a shared global clock. During each cycle, components are told to latch their inputs, once all registered components have done this, they are told to execute based on their latched inputs and to set their outputs. This system decouples the timing requirements between components which enables independent and "swappable" component design. The simulation system has an event counter and statistics generator which can output directly to spreadsheet format as well as  GUI for visualizing processor state and a debug mode for stepping through execution.

> Within this framework, an in-order multi-core MIPS based system was developed with a two level memory hierarchy, broadcast bus, and mesi/firefly/hybrid coherence protcols. The L1Cache was implemented as a fully associative cache with one word per line. Each instruction goes through five states (Fetch/decode/Execute/Memory/Writeback) before it is retired. Simple interfaces between components (eg. processing\_core < - > memory and bus < - >cache\_controller) allow us to swap between simple implementations and complex implementations to isolate components.  An assembler for MIPS assembly was written which supports comments,simple multi-threading model, macros, and memory arrays.


> The implemented ISA is 32-bit and supports ALU instructions, conditional branch/jumps, memory instructions (including extra instructions for hybrid protocol implementation), and CAS for mutual exclusion. Applications are written in a custom dialect of MIPS assembly which has built-in support for directly specifying the number of threads and their starting PC-values(as labels). This enables chaing the number of cores doing tasks without recompling the simulator. It is assumed in this particular programming model that each core will execute its instructions in order.

> A generic structure for developing cache coherence protocols was developed around our broadcast bus. The system provides abstract classes and interfaces around Cache Lines, Protocol States (No message,Ready to start transaction, and Running transaction), and the Cache Controller. These provide a scaffolding around which specific protocol implementations are developed.

> Every component within the system must have a defined latency which it is responsible for maintaining. Within the system  main memory latency was defined at 50 cycles,  bus latency at 15 cycles, and  L1-cache latency (for a cache hit) at 1 cycle. This allows for a realistic simulation of core interaction, where some cores can make progress while others are stalled waiting for responses from the bus or memory.